import random
from typing import Any, Callable, Dict, List, Optional, Tuple, Union

import algorithmx
import networkx as nx
import numpy as np


def get_maxcut_costs(graph: nx.Graph) -> np.ndarray:
    """
    Calculates the Max-Cut cost values for a given graph.

    Args:
        graph (nx.Graph): A networkx Graph object representing the graph.

    Returns:
        numpy.ndarray: A 1D numpy array containing the cost values for all possible solutions to the Max-Cut problem.

    Raises:
        TypeError: If the input graph is not a networkx Graph object.

    Example:
        import networkx as nx
        graph = nx.Graph([(0, 1), (1, 2), (2, 3)])
        costs = get_maxcut_costs(graph)
        print(costs)

    Output:
        array([0, -1, -2, -1, -2, -3, -2, -1, -1, -2, -3, -2, -1, -2, -1,  0])
    """

    if not isinstance(graph, nx.Graph):
        raise TypeError(
            "Graph is not a networkx class (found type: %s)" % type(graph).__name__
        )

    def product(*args, repeat=1):
        # product('ABCD', 'xy') --> Ax Ay Bx By Cx Cy Dx Dy
        # product(range(2), repeat=3) --> 000 001 010 011 100 101 110 111
        pools = [list(pool) for pool in args] * repeat
        result = [[]]
        for pool in pools:
            result = [x + [y] for x in result for y in pool]
        for prod in result:
            yield list(prod)

    M = graph.number_of_edges()
    N = graph.number_of_nodes()
    A = nx.adjacency_matrix(graph).todense()

    # Generate a list of all possible n‐tuples of elements from {1,-1} and
    # organize them as a (2^n x n) matrix. In other words create all
    # possible solutions to the problem.
    s = np.array(list(product([1, -1], repeat=N)))

    # Construct the the cost function for Max Cut: C=1/2*Sum(Z_i*Z_j)-M/2
    # Note: This is the minimization version
    return 1 / 2 * (np.diag(s @ np.triu(A) @ s.T) - M)


def get_maxcut_graph(n: int, seed: int) -> nx.DiGraph():
    """Generate an instance of a maxcut graph

    Args:
        n (int): Number of nodes in the graph.

    Returns:
        nx.DsGraph: A networkx graph instance.
    """
    random.seed(seed)
    G = nx.dense_gnm_random_graph(n=n, m=random.randint(n, n * (n - 1) / 2), seed=seed)
    # G = nx.dense_gnm_random_graph(n=n, m=random.randint(7, 8), seed=seed)
    for u, v in G.edges():
        G.edges[u, v]["weight"] = 1  # random.randint(0,10)
    return G


def visualize_maxcut_graph(G: nx.Graph, solution: Any = None) -> Any:
    """Visualize the maxcut graph via algorithmx.

    Args:
        G (nx.DiGraph): The graph obtained from the networkx library.
        solution (np.ndarray, optional): The solution bitstring for a given cut.
          Defaults to None.

    Returns:
        canvas (algorithmx.jupyter_canvas()): The canvas generated by the
          algorithmx library
    """
    if not isinstance(G, nx.Graph):
        raise TypeError(
            "Graph is not a networkx class (found type: %s)" % type(G).__name__
        )

    canvas = algorithmx.jupyter_canvas()

    canvas.nodes(G.nodes).add()
    canvas.edges(G.edges).add().label().add().text(lambda e: G.edges[e]["weight"])

    if type(solution) is not type(None):
        for n in G.nodes:
            if solution[n] == 1:
                canvas.node(n).color("red")

        for u, v in G.edges():
            if solution[u] != solution[v]:
                canvas.edge((u, v)).traverse("red")
    return canvas
